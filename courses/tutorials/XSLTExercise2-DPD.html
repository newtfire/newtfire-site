<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml">
   
   	
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
      <link rel="stylesheet" type="text/css" href="explain.css" />
      <title>XSLT Exercise 2</title>
   </head>
   
   
   
   <body>
      <!--#include virtual="top.html" -->
      		
      			
      <h1><span class="banner">XSLT Exercise 2</span></h1>
      <h3>Overview of the Assignment</h3>
      <p>The <a href="http://kpop.newtfire.org">Fall 2020 KPop project team</a> has coded Korean pop music group membership information in XML that we will be outputting in HTML using XSLT. This exercise will help orient you to the way we set up XSLT to output HTML, and to write XSLT template rules that follow the source document’s nested hierarchy. The XML file, which profiles the Korean pop group Seventeen, is available here: <a href="https://newtfire.org/courses/tutorials/Seventeen_Profile.xml">https://newtfire.org/courses/tutorials/Seventeen_Profile.xml</a>. You should right-click on this link, download the file, and open it in &lt;oXygen/&gt; (or you can pull it in locally from the digitProjectDesign-Hub where it is in Class Examples > XSLT > KPop).</p>
      <p>Open the XML file in oXygen and study its structure. Our goal in this assignment is to extract information about the group and its members from XML elements into HTML in a way that shows you how XSLT template rules work over all the elements they match on the source XML tree. Here is <a href="../tutorials/Seventeen.html">a view of the HTML output</a> we want to produce.</p>
<div class="code">
  
</div>
<p>The underlying HTML, which we generated by running XSLT, should look like this:</p>
<pre>
 
</pre>
   
      <p>In HTML ordered and unordered lists, the only elements permitted inside are list items or <span class="code">&lt;li&gt;</span> elements. We’ve nested them so that each list item in the outside numbered list contains a category type (designating what kind of organization), followed by an embedded <span class="code">&lt;ul&gt;</span> that contains, in turn, a separated bulleted list series, listing the name of each organization in the list.</p>
      			
      		<h3>Before You Begin: Set up the XSLT Stylesheet to Output HTML</h3>	
      <p>To ensure that the output would be in the XHTML namespace, we
         added a default namespace declaration (in <span style="color: purple;">purple</span>
         below). To output the required DOCTYPE declaration, we also created
         <code>&lt;xsl:output&gt;</code> element as a child of our root
         <code>&lt;xsl:stylesheet&gt;</code> element (in <span style="color: #006400;"
            >blue</span> below), and we needed to include an attribute there to omit the default XML declaration because if we output it that XML line in our XHTML output, it will not produce valid HTML with the w3C and might produce quirky problems with rendering in various web browsers. So, our modified stylesheet template and xsl:output line is this, and you should copy this into your stylesheet:</p>
      
      <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
         &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="3.0"
    <span style="color:purple;">xmlns="http://www.w3.org/1999/xhtml"</span>&gt;
    
   <span style="color:blue;"> &lt;xsl:output method="xhtml" encoding="utf-8" doctype-system="about:legacy-compat"
        omit-xml-declaration="yes"/&gt;</span>
    
    &lt;/xsl:stylesheet&gt;
      </pre>
     
      
      <h3>Guide to Approaching the Problem</h3>
      <p>Our XSLT transformation (after all this housekeeping) has three template rules:</p>
      <ol>
         <li>We have a template rule for the <strong>document node</strong> (<code>&lt;xsl:template
            match="/"&gt;</code>), in which we create the basic HTML file structure: the
            <code>&lt;html&gt;</code> element, <code>&lt;head&gt;</code> and its contents,
            and <code>&lt;body&gt;</code>—anything that appears just once in the HTML document (one to one relationship with the root node). Inside the <code>&lt;body&gt;</code> element that
            we’re creating, we use <code>&lt;xsl:apply-templates&gt;</code> and select the <code>&lt;listOrg&gt;</code> elements
            (using an XPath expression as the value of the <code>@select</code> attribute). And we create our wrapper <code>&lt;ol&gt;</code> tags to set up the ordered list of organization types.</li>
         <li>We have a separate template rule that matches the <code>&lt;listOrg&gt;</code> elements (holding the lists of organizations), so it will be invoked as a result of the preceding <code>&lt;xsl:apply-templates&gt;</code> instruction, and
            will fire once for each <code>&lt;listOrg&gt;</code> element in our Site Index. Inside that template rule we create a new list item
            (<code>&lt;li&gt;</code>) for the particular <code>&lt;listOrg&gt;</code> being processed and inside the tags for
            that new list item we do two things. First, we apply templates to the
            <code>&lt;head&gt;</code> for the <code>&lt;listOrg&gt;</code>, which will cause its category description to
            be output when we run the transformation. Second, we create wrapper <code>&lt;ul&gt;</code> tags for the nested
            list that will contain the names of the organizations within that category. Inside that new
            <code>&lt;ul&gt;</code> element, we use an
            <code>&lt;xsl:apply-templates&gt;</code> rule to apply templates to (that is, to
            process) the <code>&lt;org&gt;</code> elements of that <code>&lt;listOrg&gt;</code>.</li>
         <li>We have a separate template rule that matches the <code>&lt;org&gt;</code> elements, which make up the items in the list of organizations, 
            and that just applies
            templates to the <code>&lt;orgName&gt;</code> element within each <code>&lt;org&gt;</code>.
            This rule will fire once for each <code>&lt;org&gt;</code> element inside the <code>&lt;listOrg&gt;</code>, and it will be called separately for the <code>&lt;org&gt;</code> elements within each <code>&lt;listOrg&gt;</code>, so that the orgs will be rendered properly in their respective lists.</li>
      </ol>
      <p>We don’t need a template rule for the <code>&lt;head&gt;</code> elements themselves
         because the built-in (default) template rule in XSLT for an <em>element</em> that
         doesn’t have an explicit, specified rule is just to apply templates to its children. The
         only child of the <code>&lt;head&gt;</code> elements is a text node, and the built-in
         rule for <em>text nodes</em> is to output them literally. In other words, if you apply
         templates to <code>&lt;head&gt;</code> and you don’t have a template rule that matches
         that element, ultimately the transformation will just output the textual content of the
         head, that is, the title that you want.</p>
      <h3>Important</h3>
      <ul>
         <li>Those who like to read ahead or already have some programming experience with other
            languages may have noticed that XSLT includes an <code>&lt;xsl:for-each&gt;</code>
            instruction that <em>could</em> be used to solve this problem. <em>We are
               prohibiting its use for now;</em> your solution must use
            <code>&lt;xsl:template&gt;</code> and <code>&lt;xsl:apply-templates&gt;</code>
            rules instead. There’s a Good Reason for this, which we’ll explain later, when we
            talk about situations where you <em>should</em> use
            <code>&lt;xsl:for-each&gt;</code>.</li>
         <li>You may notice that two or three of your output bulleted list items show multiple related organization names squished together. This is because our editors occasionally provided more than one name used for an organization. Our standing rule is that the most definitive <code>orgName</code> be listed <em>first</em> in the list of names, so we recommend that you tidy up your list by selecting just the very first available orgName, that is, the first element child named <code>orgName</code> of <code>org</code> elements you are processing. Alternatively, you may try applying an XPath <code>string-join()</code> function to output the entries, but you will need to use <code>xsl:value-of</code> instead of <code>xsl:apply-templates</code> because we need to use <code>xsl:value-of</code> to calculate the results of functions (which removes us from the XML tree). Either approach is fine with us, and you would use the same <code>@select</code> attribute to indicate what you would like to output.</li>
         <li><em>Before submitting your homework, you must run the transformation at home</em> to
            make sure the results are what you expect them to be. Remember, there’s a guide to running
            XSLT transformations inside &lt;oXygen/&gt; in our <a href="explainXSLT.html">Intro to XSLT tutorial</a>. If you don’t get
            the results you expect and can’t figure out what you’re doing wrong, remember that you can post a query to our <a href="https://github.com/ebeshero/DHClass-Hub/issues">DHClass-Hub Issues board</a>. You can’t just ask for the answer,
            though; you need to describe what you tried, what you expected, what you got, and
            what you think the problem is. We often find, just as we’re preparing to post our
            own queries to coding discussion boards, that having to write up a description
            of the problem helps us think it through and solve it ourselves. We’re also
            encouraging you to discuss the homework on the discussion boards because that’s also
            helpful for the person who responds. Answering someone else’s
            inquiry and troubleshooting someone else’s problem often helps us clarify matters for
            ourselves!</li>
         <li>When you complete this assignment, submit your XSLT file and your output HTML file to Courseweb, following our usual homework file-naming conventions.</li>
      </ul>
      
     				
    
   </body>
   
   
   
   
</html>